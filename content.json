[{"title":"","date":"2019-04-23T08:41:10.510Z","path":"2019/04/23/12_ThreadLocal/","text":"ThreadLocal概述: ThreadLocal用于保存某个线程共享变量：对于同一个static ThreadLocal，不同线程只能从中get，set，remove自己的变量，而不会影响其他线程的变量。 方法: 1. ThreadLocal.get: 获取ThreadLocal中当前线程共享变量的值。 2. ThreadLocal.set: 设置ThreadLocal中当前线程共享变量的值。 3. ThreadLocal.remove: 移除ThreadLocal中当前线程共享变量的值。 4. ThreadLocal.initialValue: ThreadLocal没有被当前线程赋值时或当前线程刚调用remove方法后调用get方法，返回此方法值。 分析: 1. 每个Thread线程内部都有一个Map。 2. Map里面存储线程本地对象（key）和线程的变量副本（value）但是，Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向map获取和设置线程的变量值。 3. 所以对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰。"},{"title":"","date":"2019-04-23T08:41:10.503Z","path":"2019/04/23/11_Spring事务控制/","text":"Spring的事务概述: 1. JavaEE 体系进行分层开发，事务处理位于业务层，Spring 提供了分层设计 业务层的事务处理解决方案。 2. spring 框架为我们提供了一组事务控制的接口。具体在后面的第二小节介绍。这组接口是在 spring-tx-5.0.2.RELEASE.jar 中。 3. spring 的事务控制都是基于 AOP 的，它既可以使用编程的方式实现，也可以使用配置的方式实现。 事务控制的API 1. PlatformTransactionManager: 此接口是spring的事务管理器,它提供了我们常用的操作事务的方法 * 获取事务状态信息 TransactionStatus getTransaction(TransactionDefinition definition) * 提交事务 void commit(TransactionStatus status) * 回滚事务 void rollback(TransactionStatus status) 而我们都是使用它的实现类即真正管理事务的对象 org.springframework.jdbc.datasource.DataSourceTransactionManager 使用 SpringJDBC 或 iBatis 进行持久化数据时使用 org.springframework.orm.hibernate5.HibernateTransactionManager 使用Hibernate 版本进行持久化数据时使用 2. TransactionDefinition 它是事务的定义信息对象，里面有如下方法: * 获取事务对象名称: String getName() * 获取事务隔离级别 int getIsolationLevel() * 获取事务传播行为 int getPropagationBehavior() * 获取事务超时时间 int getTimeout() * 获取事务是否只读 boolean isReadOnly() 3. 事务的隔离级别 isolation_default:使用数据库默认的事务隔离级别 isolation_read_uncommitted:允许读取尚未提交的修改，可能导致脏读、幻读和不可重复读 isolation_read_committed :允许从已经提交的事务读取，可防止脏读、但幻读，不可重复读仍然有可能发生 isolation_repeatable_read:对相同字段的多次读取的结果是一致的，除非数据被当前事务自生修改。可防止脏读和不可重复读，但幻读仍有可能发生 isolation_serializable :完全服从acid隔离原则，确保不发生脏读、不可重复读、和幻读，但执行效率最低。 4. 事务的传播行为 REQUIRED:如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值） SUPPORTS:支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务） MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常 REQUERS_NEW:新建事务，如果当前在事务中，把当前事务挂起。 NOT_SUPPORTED:以非事务方式执行操作，如果当前存在事务，就把当前事务挂起 NEVER:以非事务方式运行，如果当前存在事务，抛出异常 NESTED:如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行 REQUIRED 类似的操作 5. 超时时间 默认值时-1,没有超时限制,如果有,以秒为单位设置 6. 只读 建议查询设置为只读 7. TransactionStatus 此接口提供的是事务具体的运行状态 * 刷新事务 void flush() * 获取是否存在存储点 boolean hasSavepoint() * 获取事务是否完成 boolean isCompleted() * 获取事务是否是新的事务 boolean isNewTransaction() * 获取事务是否回滚 boolean isRollbackOnly() * 设置事务回滚 void setRollbackOnly() 声明式事务的使用1. 基于xml: 1. 导入依赖jar spring-jdbc spring-tx 2. 创建spring配置文件以及导入约束 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;/beans&gt; 3. 使用spring的ioc管理对象 配置业务层以及持久层的对象 4. 具体事务的配置 1. 配置事务管理器 &lt;!--配置一个事务管理器--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!--注入一个DataSource--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;ds&quot; &gt;&lt;/property&gt; &lt;/bean&gt; 2. 配置一个通知类引用事务管理器 &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!--配置所有的方法开启事务并设置只读false,传播行为REQUIRED--&gt; &lt;tx:method name=&quot;*&quot; read-only=&quot;false&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;!--配置以find开头的方法开启事务并设置只读,传播行为SUPPORTS--&gt; &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot; propagation=&quot;SUPPORTS&quot;&gt;&lt;/tx:method&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; 3. 配置切入点以及事务与切入点的对应关系 &lt;aop:config&gt; &lt;aop:pointcut id=&quot;pt&quot; expression=&quot;execution(* com.qin.service.impl.*.*(..))&quot;&gt;&lt;/aop:pointcut&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pt&quot; &gt;&lt;/aop:advisor&gt; &lt;/aop:config&gt; 2. 基于注解: 1. 基本的对象配置同xml(只配置一个事务管理器) 2. 需要开启对注解事务的支持 &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt; 3. 在需要开启事务的类/方法上 1. @Transactional(readOnly = true,propagation = Propagation.SUPPORTS) 2. @Transactional(readOnly = false,propagation = Propagation.REQUIRED) * 注:当类上配置了事务,类里面的方法也配置了,最终会按方法上的注解生效"},{"title":"","date":"2019-04-23T08:41:10.494Z","path":"2019/04/23/10_JdbcDaoSupport/","text":"从Spring容器获取JdbcTemplate对象Spring为我们提供了一个JdbcDaoSupport类,我们的dao实现类可以通过继承来获取JdbcTemplate. 使用步骤: 1. dao中的实现类继承JdbcDaoSupport 2. 通过getJdbcTemplate()或者加上this/super来直接获取一个JdbcTemplate对象来使用 使用需求:为其注入一个DataSource 1. xml形式: 1. dao中的实现类继承JdbcDaoSupport 2. 配置xml文件 &lt;!-- dao --&gt; 给dao 注入一个datasource &lt;bean id=&quot;accountDao&quot; class=&quot;cn.itheima.dao.AccountDAOImpl&quot;&gt; &lt;!-- 当注入dataSource后，底层会自动创建一个JdbcTemplate --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;c3p0DataSource&quot; /&gt; &lt;/bean&gt; 2. 注解形式: @Repository(&quot;accountDao&quot;) public class AccountDaoImpl extends JdbcDaoSupport implements IAccountDao { // 第一种: 为dao注入dataSource. 较常用 @Autowired @Qualifier(&quot;dataSource&quot;) public void setSuperDataSource(DataSource dataSource) { super.setDataSource(dataSource); } // 第二种: 为dao注入 @Autowired private JdbcTemplate jdbcTemplate; } 本质: 就是能 拿到jdbcTemplate.执行sql语句"},{"title":"","date":"2019-04-23T08:41:10.479Z","path":"2019/04/23/09_Spring中环绕通知/","text":"Spring�еĻ���֪ͨ:1.���� ����: �����������˻���֪֮ͨ��,����㷽��û��ִ��,��֪ͨ����ִ���� ����: ͨ���Աȶ�̬����Ļ���֪ͨ����,���ֶ�̬����Ļ���֪ͨ����ȷ������㷽������.�����ǵ�û�� ���: Spring���Ϊ�����ṩ��һ���ӿ�,proceedingJoinPoint.�ýӿ���һ������proceed()�˷������൱����ȷ��������㷽��. �ýӿڿ�����Ϊ����֪ͨ�ķ�������,�ڳ���ִ��ʱ,Spring��ܻ�Ϊ�����ṩ�ýӿڵ�ʵ���๩����ʹ�� Spring�еĻ���֪ͨ: ����spring���Ϊ�����ṩ��һ�ֿ����ڴ������ֶ�������ǿ������ʱִ�еķ�ʽ 2. ʹ�� 2.1 ����ע��: @Aspect public class AnnotationAudienceAround{ //ʹ��@Pointcutע�������������ʽ @Pointcut(&quot;execution(* com.qin.util.*.*(..))&quot;) public void pt1(){} @Around(&quot;pt1()&quot;) public Object aroundPringLog(ProceedingJoinPoint pjp){ Object rtValue = null; try{ Object[] args = pjp.getArgs();//�õ�����ִ������Ĳ��� System.out.println(&quot;Logger���е�aroundPringLog������ʼ��¼��־�ˡ�����ǰ��&quot;); rtValue = pjp.proceed(args);//��ȷ����ҵ��㷽��������㷽���� System.out.println(&quot;Logger���е�aroundPringLog������ʼ��¼��־�ˡ���������&quot;); return rtValue; }catch (Throwable t){ System.out.println(&quot;Logger���е�aroundPringLog������ʼ��¼��־�ˡ������쳣&quot;); throw new RuntimeException(t); }finally { System.out.println(&quot;Logger���е�aroundPringLog������ʼ��¼��־�ˡ���������&quot;); } } } 2.2 ����XML�����ļ�: 1. ֪ͨ��. //ȥ�������е�ע�� public class XmlAudienceAround{ public Object aroundPringLog(ProceedingJoinPoint pjp){ Object rtValue = null; try{ Object[] args = pjp.getArgs();//�õ�����ִ������Ĳ��� System.out.println(&quot;Logger���е�aroundPringLog������ʼ��¼��־�ˡ�����ǰ��&quot;); rtValue = pjp.proceed(args);//��ȷ����ҵ��㷽��������㷽���� System.out.println(&quot;Logger���е�aroundPringLog������ʼ��¼��־�ˡ���������&quot;); return rtValue; }catch (Throwable t){ System.out.println(&quot;Logger���е�aroundPringLog������ʼ��¼��־�ˡ������쳣&quot;); throw new RuntimeException(t); }finally { System.out.println(&quot;Logger���е�aroundPringLog������ʼ��¼��־�ˡ���������&quot;); } } } 2. ��xml�ļ������� &lt;!--����bean--&gt; &lt;bean name=&quot;xmlAudienceAround&quot; class=&quot;com.qin.util.XmlAudienceAround&quot;/&gt; &lt;!--�������漰֪ͨ--&gt; &lt;aop:config&gt; &lt;aop:aspect ref=&quot;xmlAudienceAround&quot;&gt; &lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(* com.qin.util.*.*(..))&quot;/&gt; &lt;aop:around method=&quot;aroundPringLog&quot; pointcut-ref=&quot;pt1&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;"},{"title":"","date":"2019-04-23T08:41:10.473Z","path":"2019/04/23/08_动态代理以及Spring的AOP/","text":"��̬�����ص�: �ֽ��������洴��,��������� ����: ���޸�Դ��Ļ����϶Է�����ǿ ����: 1. ���ڽӿڵĶ�̬���� �漰����: Proxy �ṩ��: jdk�ٷ� ��δ����������: ʹ��Proxy���е�newProxyInstance���� ������������Ҫ��: �������������ʵ��һ���ӿ�,���û������ʹ�� newProxyInstance�����Ĳ���: ClassLoader:������� �������ڼ��ش�������ֽ����,�ͱ��������ʹ����ͬ���������,�̶�д�� Class[]:�ֽ������� ���������ô������ͱ������������ͬ�ķ���,�̶�д�� InvocationHandler:�����ṩ��ǿ�Ĵ��� ��������������д��δ���,����һ�㶼��дһ���ýӿڵ�ʵ����,ͨ����һ�������ڲ���(���Ǳ����) �˽ӿڵ�ʵ���඼��˭��˭д *���ڵ�����:�����ǵ���û��ʵ���κεĽӿڵ�ʱ���ǲ�����ʹ�õ� �������ִ�з���,��ʵ���Ǵ��汻�������ִ�з��� ���������ʵ�ֽӿ� ���ɴ������ �������.���������ķ��� 2. ��������Ķ�̬����(cglib) �漰����: Enhancer �ṩ��: ������cglib�� ��δ����������: ʹ��Enhancer���е�create���� ������������Ҫ��: ��������಻��������,���ܱ�final���� create�����Ĳ���: Class:�ֽ��� ��������ָ�������������ֽ��� Callback:�����ṩ��ǿ�Ĵ��� ��������������д��δ���,����һ�㶼��дһ���ýӿڵ�ʵ����,ͨ����һ�������ڲ���(���Ǳ����) �˽ӿڵ�ʵ���඼��˭��˭д ����һ��д�Ķ��Ǹýӿڵ��ӽӿ�ʵ����:MethodIntercepor Spring�е�AOP����: AOP��ȫ���� Aspect Oriented Programming �������������̡� �򵥵�˵�����ǰ����ǳ����ظ��Ĵ����ȡ����������Ҫִ�е�ʱ��ʹ�ö�̬����ļ������ڲ��޸�Դ��� �����ϣ������ǵ����з���������ǿ �����Լ�����: ���ã� �ڳ��������ڼ䣬���޸�Դ������з���������ǿ�� ���ƣ� �����ظ����� ��߿���Ч�� ά������ ʵ�ַ�ʽ: ʹ�ö�̬������ AOP�������: ���ӵ�: Ŀ���������з���(���е�����㶼�����ӵ�) �����: ����ǿ�Ķ�������� ��ǿ/֪ͨ: ������ǿ�Ĵ����(�����ǳ�ȡ��������) ����: ��һ�������֪ͨ�ڲ��޸�������ǰ����, Introduction ������������Ϊ�ද̬�����һЩ������ Field�� Target: ������Ķ��� ֯��: ��ָ����ǿӦ�õ�Ŀ������������µĴ������Ĺ��̡� spring ���ö�̬����֯�룬�� AspectJ ���ñ�����֯�����װ����֯�롣 ����(Proxy): һ���౻AOP֯����ǿ��,�����Ľ�������� ����: �������֪ͨ�Ľ�� Spring��AOP�����д���ʽ��ѡ��proxy-target-class Ĭ��false: �Զ�ѡ�� true: ʹ��cglib���� 1. ����XML�� &lt;aop:config proxy-target-class=&quot;true&quot;&gt; ..... &lt;/aop:config&gt; 2. ����ע�� &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;&gt;&lt;/aop:aspectj-autoproxy&gt;"},{"title":"","date":"2019-04-23T08:41:10.461Z","path":"2019/04/23/07_spring整合junit/","text":"Spring����Junit* ����:��spring�е�junit���޷�ʹ�������Ķ��� * ���� 1. �����������Ҫmain���� 2. junit�����п��Բ���Ҫmain����,ֻ��ִ����@Testע��ķ��� 3. junit����������Ƿ����spring��� ��ִ�в��Է���ʱ��junit������֪�������ǲ���ʹ����spring��� ����Ҳ�Ͳ���Ϊ���Ƕ�ȡ�����ļ�/�����ഴ��spring�������� * ����: �����Է���ִ��ʱ��û��Ioc����������д��Autowiredע�⣬Ҳ�޷�ʵ��ע�� * ����취: 1. ����spring����junit��jar(����) spring-test 2. ʹ��junit�ṩ��һ��ע���ԭ�е�main�����滻��,�滻��spring���ṩ�� @RunWith: @RunWith(SpringJUnit4ClassRunner.class) 3. ��֪spring��������,spring��ioc�����ǻ���xml���ǻ���ע���.����˵��λ�� @ContextConfiguration location:ָ��xml�ļ���λ��,����classpath�ؼ���,��ʾ����·���� @ContextConfiguration(locations = &quot;classpath:ApplicationContext.xml&quot;) classes:ָ��ע�������ڵ�λ�� @ContextConfiguration(classes = SpringConfig.class) * ������ʹ��spring5�汾��ʱ��,Ҫ��junit��jar��������4.1.2�Լ����� 4. ��ʹ�õ�ʱ��ֱ���ڱ����ϼ�@Autowiredע��Ϳ��� * ��: @RunWith(SpringJUnit4ClassRunner.class) //@ContextConfiguration(locations=&quot;classpath:ApplicationContext.xml&quot;)//����xml @ContextConfiguration(classes = SpringConfig.class)//����ע�� public class SpringJunit { @Autowired private IAccountService service; @Test public void testFindAll(){ List&lt;Account&gt; all = service.findAll(); for (Account account : all) { System.out.println(account); } } }"},{"title":"","date":"2019-04-23T08:41:10.458Z","path":"2019/04/23/06_DButils的使用/","text":"DButils�Ļ���ʹ��1. ��ȡQueryRunner����(�൱��JdbcTemplate) ����(����): QueryRunner runner = new QueryRunner(); QueryRunner runner = new QueryRunner(param); ����: ��һ��û�в��� �ڶ����Ĳ��������ݿ����ӳ�(����ʹ��c3p0/druid) 2. ִ��sql��� ��ɾ��: runner.update(����ɾ��sql��,�����б�); ��ѯ: runner.query(����ѯsql��,�������ݣ������б�); ��: runner.update(&quot;insert into account(name,money)values(?,?)&quot;,account.getName(),account.getMoney()); ɾ: runner.update(&quot;delete from account where id = ? &quot;,account.getId()) ��: runner.update(&quot;update account set name = ? and money=? where id = ?&quot;,account.getName(),account.getMoney() ,account.getId()) ��: ��һ�� runner.query(&quot;select * from account where id = ?&quot;,new BeanHandler&lt;Account&gt;(Account.class),id) ���� runner.query(&quot;select * from account&quot;, new BeanListHandler&lt;Account&gt;(Account.class)) * ע: һ������ʹ��BeanHandler ��������ʹ��BeanListHandler DButils��Spring��IOC��Ӧ��*����xml������:(����ķ�ʽ����ds) &lt;bean class=&quot;org.apache.commons.dbutils.QueryRunner&quot; id=&quot;queryRunner&quot;&gt; &lt;constructor-arg name=&quot;ds&quot; ref=&quot;c3p0DataSource&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=&quot;c3p0DataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password&quot;&gt;&lt;/property&gt; &lt;/bean&gt; * ����ע������� @Configuration //��Ϊע���ļ���ʶ�� @PropertySource(&quot;classpath:jdbcConfig.properties&quot;)//����������ݿ������ļ� @ComponentScan({&quot;com.qin&quot;,&quot;Config&quot;}) //ɨ���ļ� public class SpringConfig { //����jdbc���������� @Value(&quot;${jdbc.driver}&quot;) private String driver; @Value(&quot;${jdbc.url}&quot;) private String url; @Value(&quot;${jdbc.username}&quot;) private String username; @Value(&quot;${jdbc.password}&quot;) private String password; @Bean public QueryRunner getQueryRunner(DataSource dataSource){ return new QueryRunner(dataSource); } @Bean public DataSource getDataSource(){ try { ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource(); comboPooledDataSource.setDriverClass(driver); comboPooledDataSource.setJdbcUrl(url); comboPooledDataSource.setUser(username); comboPooledDataSource.setPassword(password); return comboPooledDataSource; } catch (PropertyVetoException e) { e.printStackTrace(); return null; } } }"},{"title":"","date":"2019-04-23T08:41:10.446Z","path":"2019/04/23/05_spring中注解形式的AOP/","text":"Spring�л���ע���AOP1. Ŀ����� ��������Ķ��� ��:ҵ����AccountServiceImpl 2. ֪ͨ���� ��ɢ�����������п��Գ�ȡ�ɹ��ԵĴ����,������ȡ��Ϊһ����(������־��¼,�������ܼ��) 3. �ں��������п����AOP��֧�� &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; 4. ʹ��ע����֪ͨ���������� 4.0 ��ʾ��ǰ����һ�������� @Aspect 4.1 �����е� @Pointcut(&quot;execution(* com.itheima.service.impl.*.update(..))&quot;) private void pt1(){} @Pointcut(&quot;execution(* com.itheima.service.impl.*.save(..))&quot;) private void pt2(){} 4.3 �ڷ���������ע�� @Before ǰ��֪ͨ @After ����֪ͨ @AfterReturning ����֪ͨ @AfterThrowing �쳣֪ͨ @Around ����֪ͨ"},{"title":"","date":"2019-04-23T08:41:10.415Z","path":"2019/04/23/04_spring中XML形式的AOP/","text":"Spring�л���XML��AOP������1. ��֪ͨbean����Spring������ 2. ʹ��aop:config��ǩ������ʼAOP������ 3. ʹ��aop:aspect��ǩ������ʼ�������� id����:�������ṩһ��Ψһ��ʶ ref����:��ָ��֪ͨ��bean��id 4. ��aop:aspect��ǩ���ڲ�ʹ�ö��õı�ǩ������֪ͨ������ ǰ��֪ͨ: aop:before(��ʾ����ǰ��֪ͨ) method����:����ָ�������ĸ�������ǰ��֪ͨ pointcut����:����ָ���������ʽ,�ñ��ʽ�ĺ���ָ���Ƕ�ҵ������Щ������ǿ �������ʽ��д��: �ؼ���: execution(���ʽ) ���ʽ: �������η� ����ֵ ����.����...����.������(�����б�) ��׼���ʽ��д��: execution(public void com.qin.service.impl.AccountServiceImpl.xxx(..)) �������η�����ʡ�� void com.itheima.service.impl.AccountServiceImpl.saveAccount() ����ֵ����ʹ��ͨ�������ʾ���ⷵ��ֵ * com.itheima.service.impl.AccountServiceImpl.saveAccount() ��������ʹ��ͨ�������ʾ������������м�����������Ҫд����*. * *.*.*.*.AccountServiceImpl.saveAccount()) ��������ʹ��..��ʾ��ǰ�������Ӱ� * *..AccountServiceImpl.saveAccount() �����ͷ�����������ʹ��*��ʵ��ͨ�� * *..*.*() �����б� ����ֱ��д�������ͣ� ��������ֱ��д���� int ��������д����.�����ķ�ʽ java.lang.String ����ʹ��ͨ�����ʾ�������ͣ����Ǳ����в��� ����ʹ��..��ʾ���޲������ɣ��в����������������� ȫͨ��д���� * *..*.*(..) ʵ�ʿ������������ʽ��ͨ��д���� �е�ҵ���ʵ�����µ����з��� * com.itheima.service.impl.*.*(..) 5. �� &lt;!-- ����Ŀ����--&gt; &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;&lt;/bean&gt; &lt;!-- ����֪ͨ�� --&gt; &lt;bean id=&quot;logger&quot; class=&quot;com.itheima.utils.Logger&quot;&gt;&lt;/bean&gt; &lt;!--����AOP--&gt; &lt;aop:config&gt; &lt;!-- �����������ʽ id��������ָ�����ʽ��Ψһ��ʶ��expression��������ָ�����ʽ���� �˱�ǩд��aop:aspect��ǩ�ڲ�ֻ�ܵ�ǰ����ʹ�á� ��������д��aop:aspect���棬��ʱ�ͱ��������������� --&gt; &lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(* com.itheima.service.impl.*.*(..))&quot;&gt;&lt;/aop:pointcut&gt; &lt;!--�������� --&gt; &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt; &lt;!-- ����ǰ��֪ͨ��������㷽��ִ��֮ǰִ��--&gt; &lt;aop:before method=&quot;beforePrintLog&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:before&gt; &lt;!-- ���ú���֪ͨ��������㷽������ִ��֮��ֵ�������쳣֪ͨ��Զֻ��ִ��һ��--&gt; &lt;aop:after-returning method=&quot;afterReturningPrintLog&quot; pointcut-ref=&quot;pt1&quot; returning=&quot;val&quot;&gt;&lt;/aop:after-returning&gt; &lt;!-- �����쳣֪ͨ��������㷽��ִ�в����쳣֮��ִ�С����ͺ���֪ͨ��Զֻ��ִ��һ��--&gt; &lt;aop:after-throwing method=&quot;afterThrowingPrintLog&quot; pointcut-ref=&quot;pt1&quot; throwing=&quot;ex&quot;&gt;&lt;/aop:after-throwing&gt; &lt;!-- ��������֪ͨ����������㷽���Ƿ�����ִ���������������ִ��--&gt; &lt;aop:after method=&quot;afterPrintLog&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after&gt; &lt;!-- ���û���֪ͨ --&gt; &lt;aop:around method=&quot;aroundPringLog&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:around&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;"},{"title":"","date":"2019-04-23T08:41:10.388Z","path":"2019/04/23/03_spring抽取配置文件/","text":"Spring��ȡ�������ݿ��ļ�1.��ȡ�ļ�: jdbcConfig.properties jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/spring jdbc.username=root jdbc.password=root 2. ��Spring�������ļ�������: &lt;context:property-placeholder location=&quot;jdbcConfig.properties&quot;&gt;&lt;/context:property-placeholder&gt; ʹ��ע�������Ϊ: @PropertySource(&quot;classpath:jdbcConfig.properties&quot;) 3. ��ԭ���������ļ���ʹ��Spring��el���ʽ ${}����ʾ &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password&quot;&gt;&lt;/property&gt;"},{"title":"","date":"2019-04-23T08:41:10.358Z","path":"2019/04/23/02_spring中注解形式的IOC/","text":"Spring的注解开发* IOC在XML的配置:&lt;bean id=&quot;accountService&quot; class=&quot;com.qin.service.impl.AccountService&quot; scope=&quot;&quot; init-method=&quot;&quot; destory-method=&quot;&quot;&gt; &lt;property name=&quot;&quot; value=&quot;&quot; |ref=&quot;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; * 注解分类: 1. 用于创建对象的 它们的作用就和xml配置中编写一个&lt;bean&gt;标签实现的功能是一样的 @Component: 作用: 用于把当前类对象存入Spring容器中 属性: value:用于指定bean中的id.当我们不写时,他的默认值是当前类名的,且首字母小写 @Controller:一般用在表现层 @Service:一般用在业务层 @Repository:一般用在持久层 以上三个注解的作用和属性与Component是一模一样的 他们三个是spring为我们提供明确的三层使用的注解,使我们的三层对象更加清晰 在xml文件的配置: &lt;context:component-scan base-package=&quot;com.qin&quot;&gt;&lt;/context:component-scan&gt; 作用:告知spring在创建容器时要扫描的包,配置所需要的标签不是beans约束中,而是在context 的名称空间和约束中 约束配置: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; 2. 用于注入数据的 它们的作用就和在xml配置文件中的bean标签中写一个&lt;property&gt;标签的作用是一样的 @Autowired 作用:(自动按照类型注入) 如果ioc容器中有唯一的一个bean对象类型和要注入的变量类型匹配,就可以注入成功 如果ioc容器中没有任何bean类型和要注入的变量类型一致,将会注入失败 如果ioc容器中有多个bean类型和要注入的变量类型一致,会先根据类型寻找,再根据变量名找 出现位置: 变量上,方法上(在set方法上也可以使用); 细节: 在使用注解注入时,set方法就不是必须的 @Qualifier * 配合@Autowired使用 * 也可以存在于参数上,配合指定构造中要传递的bean对象 作用: 在按照类中注入的基础之上再按照名称注入.他在给类成员注入时不能单独使用,但是在给方法参数注入时可以 属性: value:用于指定注入bean的id @Resource * jdk1.9不能使用 作用: 直接按照bean的id注入,它可以单独使用 属性: name:用于指定bean 的id * 以上三个注入都只能注入其他bean类型,而基本类型和string类型无法使用上述注解实现,集合类型也可以用Autowired实现 @Value 作用: 用于注入基本类型和string类型的数据 属性: value:用于指定数据的值.他可以使用spring和spEL(也就是spring的el表达式) spEL的写法:#{表达式} #{}:去容器中找id为花括号内容对应的值 ${}:去配置文件中读取花括号对应的值 3. 用于改变作用范围的 它们的作用就和在xml配置文件中的bean标签中使用scope属性实现的功能是一样的 @Scope 作用: 用于指定bean的作用范围 属性: value:指定范围的取值.常用取值:singleton prototype 4. 和生命周期相关 它们的作用就和在xml配置文件中的bean标签中使用init-method和destory-method的作用是一样的 @PreDestroy 作用: 用于指定销毁方法 @PostConstruct 作用: 用于指定初始化方法 * spring的新注解(可以使用纯注解的形式开发) * 创建一个类.替换核心配置文件 @Configuration 作用: 指定当前类是一个配置类 细节: 当配置类作为AnnotationConfigApplicationContext对象创建的参数时,可以不写此注解 但不是任何时候都可以不写(把注解文件分开写,另一个没有读的配置文件必须写) @ConponentScan 作用: 用于通过注解指定spring在创建容器时要扫面的包 属性: value:它和basePackage的作用是一样的,都是用于指定创建容器时要扫面的包 我们使用次注解就等同于在xml中配置了: &lt;context:component-scan base-package=&quot;com.qin&quot;&gt;&lt;/context:component-scan&gt; @Bean 作用: 用于把当前方法的的返回值作为bean对象存入spring的ioc容器中 属性: name:用于指定bean的id,当不写时,默认值是当前方法的名称 细节: 当我们使用注解来配置方法时,如果方法有参数,spring框架会去容器中查找有没有可用的bean对象,查找的方式和 @Autowired注解的作用一样的 @Import 作用: 用于导入其他的配置类 属性: value:用于指定其他配置类的字节码文件 当我们使用import的注解之后,有import注解的类就是父配置类,而导入的都是子配置类 @PropertySource 作用: 用于指定properties文件的位置 属性: value:指定文件的名称以及文件的路径 关键字:classpath,表示类路径下 例子: @PropertySource(&quot;classpath:JdbcConfig.properties&quot;) *没有xml文件时测试就要修改ApplicationContext的创建方式 ApplicationContext ac = new AnnotationConfigApplicationContext(&quot;被@Configuration注解过的类&quot;.class)"},{"title":"","date":"2019-04-23T08:41:10.344Z","path":"2019/04/23/01_spring中XML形式的IOC/","text":"Spring引入* spring 是什么? Spring是分层的 Java SE/EE应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control： 反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核，提供了展现层 Spring MVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多 著名的第三方框架和类库，逐渐成为使用最多的Java EE 企业应用开源框架。 * 程序的耦合 耦合:程序之间的依赖关系 包括了类与类之间的依赖,方法之间的依赖 解耦:降低程序之间的依赖关系,提升程序的灵活性与可扩展性 实际开发中:应该做到编译期不依赖,运行时才会依赖 解耦的思路: 第一步:使用反射来创建对象,从而避免使用new关键字 第二步:通过读取配置文件来获取要创建的对象全限定类名 * 三层架构代码中存在的问题 业务层调用持久层的时候的new dao的接口 在表现层调用业务层的时候new service的接口 解决办法: 使用工厂模式解耦(一个创建bean对象的工厂) Bean 1. Bean:在计算机英语中,有可重用组件的含义 2. JavaBean:用java语言编写的可重用组件 JavaBean &gt; 实体类 3. POJO（Plain Ordinary Java Object）即普通Java类 4. 可以认为POJO就一个不带方法而单纯承载数据实体Bean；EJB是一个包含了POJO的超集、 包含POJO之外的，具有方法、实现、功能这一群组件。 方法: 1. 一个配置文件配置service与dao的内容(xml/properties) 2. 通过读取配置文件来获取要创建的对象全限定类名,反射加载 3.优化:使用单例 Spring的IOC(Inversion Of Control)* IOC:控制反转 简单理解:让spring来控制对象 一般的pojo或者domain实体类是不会让spring去管理的 通常来说,我们自己写的类,使用注解,别人写的类(引入的类)一般使用xml * 入门案例: 1. 导入依赖 2. 创建配置文件,导入约束,并写入相关的bean标签(配置id与class) 3. 从容器中获取容器对象 3.1 先获取容器 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;配置文件&quot;) 3.2 从容器中根据id或者name获取bean对象 User user = ac.getBean(&quot;user&quot;, User.class); System.out.println(user);//User{userName=&apos;null&apos;, age=null, birthday=null} * ApplicationContext的三个常用的实现类 ClassPathXmlApplicationContext:它可以加载类路径下的配置文的件,要求配置文件必须在类路径下,不在就加载不了 (xml常用) FileSystemXmlApplicationContext:它可以加载磁盘任意路径下的配置文件 (必须有访问权限) AnnotationConfigApplicationContext:它是用于读取注解的配置 (注解时使用) * 核心容器的两个接口引发出的问题 ApplicationContext:(单例对象试用),多使用此接口 它在构建核心容器的时候,创建对象采取的是立即加载的方式,也就是说,只要一读取完配置文件就马上 就创建配置文件中的配置的对象 BeanFactory:(多例对象适用) 它在构建核心容器的时候,采取的策略是延迟加载的方式,也就是说,什么时候根据id获取对象了,什么时候才会 真正的创建对象 * Spring对bean的管理细节 1. 创建bean的三种方式: 1.1 第一种方式:使用默认构造函数创建 在spring的配置文件中使用bean标签,配置id与class属性之后,且没有其他属性和标签时 采用的就是默认构造函数创建bean对象,测试如果类中没有默认构造函数,则对象无法创建 &lt;bean id=&quot;service&quot; class=&quot;com.qin.service.impl.IUserServiceImpl&quot;&gt;&lt;/bean&gt; 1.2 第二种方式:使用普通工厂中的方法来创建对象(使用某个类中的方法创建对象,并存入spring容器) &lt;bean id=&quot;instanceFactory&quot; class=&quot;com.qin.factory.instanceFactory&quot;&gt;&lt;/bean&gt;(要先有对象才能调用方法) &lt;bean id=&quot;serviceFactory&quot; class=&quot;com.qin.factory.instanceFactory&quot; factory-method=&quot;getAccount&quot;&gt; &lt;/bean&gt; 1.3 第三种方式:使用工厂中的静态方法创建对象(使用某个类中的静态方法创建对象,并存入spring容器) &lt;bean id=&quot;serviceFactory&quot; class=&quot;com.qin.factory.StaticFactory&quot; factory-method=&quot;getAccount&quot;&gt; &lt;/bean&gt; 静态方法是不需要对象的,是可以通过全类名调用的,所以不需要对象 2. bean的作用范围 bean标签的scope属性 作用:用于指定bean 的作用范围 取值: singleton:单例的(默认值) prototype:多例的 request:作用于wen应用的请求范围 session:作用于wen应用的会话范围 global-session:作用于集群环境的会话范围(全局会话范围),当不是集群的时候,相当于session 3. bean对象的生命周期 单例对象: 出生:当容器创建时候对象出生 存在:只要容器在,对象就一直活着 死亡:容器销毁,对象消亡 总结:单例对象的生命周期和容器相同 多例对象: 出生:当使用对象时,spring框架为我们创建 存在:对象还在使用的过程中就一直存活 死亡:当对象长时间不用,且没有别的对象引用时,由java的垃圾回收器回收 Spring依赖注入:DI(依赖关系的维护)* 能注入的数据:三类 1. 基本类型和string : 2. 其他bean类型(在配置文件中或者注解配置过的bean) 3. 复杂类型/集合类型 * 注入的方式:有三种 1. 使用构造函数提供(不常用) 使用的标签:constructor-arg 标签出现的位置:bean标签的内部 标签的属性: type:用于指定要注入的数据的数据类型,该数据类型也是构造函数中某个或某些参数的类型 index:用于指定要注入的数据给构造函数中指定索引位置的参数赋值,索引的位置是从0开始的 name:用于指定给构造函数中指定名称的参数赋值(常用) ---------------以上三个用于指定给构造函数中的哪个参数赋值-------------------- value:用于提供基本类型和string类型的数据 ref:用于指定其他的bean类型数据.他指的就是在spring的核心容器中出现过的bean对象 优势: 在获取bean对象时,注入数据是必须的操作,否则对象无法创建成功. 弊端: 改变了bean对象的实例化方式,使我们在创建对象时,如果不使用这些数据也必须提供. 2. 使用set方法提供(常用) * 首先必须有set方法 涉及的标签:property 出现的位置:bean标签的内部 标签的属性: name:用于指定注入时调用的set方法名称 value:用于提供基本类型和string类型的数据 ref:用于指定其他的bean类型数据.他指的就是在spring的核心容器中出现过的bean对象 优势:创建对象时没有明确的限制,可以直接使用默认构造函数 弊端:如果某个成员必须有值,则获取对象是有可能set方法没有执行 3. 使用注解提供 * 示例: 1. 构造函数注入 &lt;bean id=&quot;userDao&quot; class=&quot;com.qin.dao.impl.IUserDaoImpl&quot;&gt; &lt;constructor-arg name=&quot;userName&quot; value=&quot;sakura&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;birthday&quot; ref=&quot;date&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=&quot;date&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt; 2. 使用set方法注入 &lt;bean id=&quot;userDao1&quot; class=&quot;com.qin.dao.impl.IUserDaoImpl1&quot;&gt; &lt;property name=&quot;age&quot; value=&quot;19&quot;&gt;&lt;/property&gt; &lt;property name=&quot;userName&quot; value=&quot;tom&quot;&gt;&lt;/property&gt; &lt;property name=&quot;birthday&quot; ref=&quot;date&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;date&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt; 3. 对集合属性进行set方式注入 &lt;bean id=&quot;userDao2&quot; class=&quot;com.qin.dao.impl.IUserDaoImpl2&quot;&gt; &lt;property name=&quot;myStrs&quot;&gt; &lt;array&gt; &lt;value&gt;string&lt;/value&gt; &lt;value&gt;string&lt;/value&gt; &lt;value&gt;string&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=&quot;myList&quot;&gt; &lt;list&gt; &lt;value&gt;list&lt;/value&gt; &lt;value&gt;list&lt;/value&gt; &lt;value&gt;list&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;mySet&quot;&gt; &lt;set&gt; &lt;value&gt;set&lt;/value&gt; &lt;value&gt;set&lt;/value&gt; &lt;value&gt;set&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=&quot;myMap&quot;&gt; &lt;map&gt; &lt;entry key=&quot;map1&quot;&gt; &lt;value&gt;map1&lt;/value&gt; &lt;/entry&gt; &lt;entry key=&quot;map2&quot; value=&quot;map2&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;map3&quot; value=&quot;map3&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;myProps&quot;&gt; &lt;props&gt; &lt;prop key=&quot;prop&quot;&gt;123&lt;/prop&gt; &lt;prop key=&quot;prop&quot;&gt;123&lt;/prop&gt; &lt;prop key=&quot;prop&quot;&gt;123&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;"},{"title":"Hello World","date":"2019-04-23T08:36:59.110Z","path":"2019/04/23/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]