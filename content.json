[{"title":"ThreadLocal","date":"2019-04-23T08:41:10.510Z","path":"2019/04/23/12_ThreadLocal/","text":"ThreadLocal概述: ThreadLocal用于保存某个线程共享变量：对于同一个static ThreadLocal，不同线程只能从中get，set，remove自己的变量，而不会影响其他线程的变量。 方法: 1. ThreadLocal.get: 获取ThreadLocal中当前线程共享变量的值。 2. ThreadLocal.set: 设置ThreadLocal中当前线程共享变量的值。 3. ThreadLocal.remove: 移除ThreadLocal中当前线程共享变量的值。 4. ThreadLocal.initialValue: ThreadLocal没有被当前线程赋值时或当前线程刚调用remove方法后调用get方法，返回此方法值。 分析: 1. 每个Thread线程内部都有一个Map。 2. Map里面存储线程本地对象（key）和线程的变量副本（value）但是，Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向map获取和设置线程的变量值。 3. 所以对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰。"},{"title":"Spring事务","date":"2019-04-23T08:41:10.503Z","path":"2019/04/23/11_Spring事务控制/","text":"Spring的事务概述: 1. JavaEE 体系进行分层开发，事务处理位于业务层，Spring 提供了分层设计 业务层的事务处理解决方案。 2. spring 框架为我们提供了一组事务控制的接口。具体在后面的第二小节介绍。这组接口是在 spring-tx-5.0.2.RELEASE.jar 中。 3. spring 的事务控制都是基于 AOP 的，它既可以使用编程的方式实现，也可以使用配置的方式实现。 事务控制的API 1. PlatformTransactionManager: 此接口是spring的事务管理器,它提供了我们常用的操作事务的方法 * 获取事务状态信息 TransactionStatus getTransaction(TransactionDefinition definition) * 提交事务 void commit(TransactionStatus status) * 回滚事务 void rollback(TransactionStatus status) 而我们都是使用它的实现类即真正管理事务的对象 org.springframework.jdbc.datasource.DataSourceTransactionManager 使用 SpringJDBC 或 iBatis 进行持久化数据时使用 org.springframework.orm.hibernate5.HibernateTransactionManager 使用Hibernate 版本进行持久化数据时使用 2. TransactionDefinition 它是事务的定义信息对象，里面有如下方法: * 获取事务对象名称: String getName() * 获取事务隔离级别 int getIsolationLevel() * 获取事务传播行为 int getPropagationBehavior() * 获取事务超时时间 int getTimeout() * 获取事务是否只读 boolean isReadOnly() 3. 事务的隔离级别 isolation_default:使用数据库默认的事务隔离级别 isolation_read_uncommitted:允许读取尚未提交的修改，可能导致脏读、幻读和不可重复读 isolation_read_committed :允许从已经提交的事务读取，可防止脏读、但幻读，不可重复读仍然有可能发生 isolation_repeatable_read:对相同字段的多次读取的结果是一致的，除非数据被当前事务自生修改。可防止脏读和不可重复读，但幻读仍有可能发生 isolation_serializable :完全服从acid隔离原则，确保不发生脏读、不可重复读、和幻读，但执行效率最低。 4. 事务的传播行为 REQUIRED:如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值） SUPPORTS:支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务） MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常 REQUERS_NEW:新建事务，如果当前在事务中，把当前事务挂起。 NOT_SUPPORTED:以非事务方式执行操作，如果当前存在事务，就把当前事务挂起 NEVER:以非事务方式运行，如果当前存在事务，抛出异常 NESTED:如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行 REQUIRED 类似的操作 5. 超时时间 默认值时-1,没有超时限制,如果有,以秒为单位设置 6. 只读 建议查询设置为只读 7. TransactionStatus 此接口提供的是事务具体的运行状态 * 刷新事务 void flush() * 获取是否存在存储点 boolean hasSavepoint() * 获取事务是否完成 boolean isCompleted() * 获取事务是否是新的事务 boolean isNewTransaction() * 获取事务是否回滚 boolean isRollbackOnly() * 设置事务回滚 void setRollbackOnly() 声明式事务的使用1. 基于xml: 1. 导入依赖jar spring-jdbc spring-tx 2. 创建spring配置文件以及导入约束 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;/beans&gt; 3. 使用spring的ioc管理对象 配置业务层以及持久层的对象 4. 具体事务的配置 1. 配置事务管理器 &lt;!--配置一个事务管理器--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!--注入一个DataSource--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;ds&quot; &gt;&lt;/property&gt; &lt;/bean&gt; 2. 配置一个通知类引用事务管理器 &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!--配置所有的方法开启事务并设置只读false,传播行为REQUIRED--&gt; &lt;tx:method name=&quot;*&quot; read-only=&quot;false&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;!--配置以find开头的方法开启事务并设置只读,传播行为SUPPORTS--&gt; &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot; propagation=&quot;SUPPORTS&quot;&gt;&lt;/tx:method&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; 3. 配置切入点以及事务与切入点的对应关系 &lt;aop:config&gt; &lt;aop:pointcut id=&quot;pt&quot; expression=&quot;execution(* com.qin.service.impl.*.*(..))&quot;&gt;&lt;/aop:pointcut&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pt&quot; &gt;&lt;/aop:advisor&gt; &lt;/aop:config&gt; 2. 基于注解: 1. 基本的对象配置同xml(只配置一个事务管理器) 2. 需要开启对注解事务的支持 &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt; 3. 在需要开启事务的类/方法上 1. @Transactional(readOnly = true,propagation = Propagation.SUPPORTS) 2. @Transactional(readOnly = false,propagation = Propagation.REQUIRED) * 注:当类上配置了事务,类里面的方法也配置了,最终会按方法上的注解生效"},{"title":"","date":"2019-04-23T08:41:10.494Z","path":"2019/04/23/10_JdbcDaoSupport/","text":"从Spring容器获取JdbcTemplate对象Spring为我们提供了一个JdbcDaoSupport类,我们的dao实现类可以通过继承来获取JdbcTemplate. 使用步骤: 1. dao中的实现类继承JdbcDaoSupport 2. 通过getJdbcTemplate()或者加上this/super来直接获取一个JdbcTemplate对象来使用 使用需求:为其注入一个DataSource 1. xml形式: 1. dao中的实现类继承JdbcDaoSupport 2. 配置xml文件 &lt;!-- dao --&gt; 给dao 注入一个datasource &lt;bean id=&quot;accountDao&quot; class=&quot;cn.itheima.dao.AccountDAOImpl&quot;&gt; &lt;!-- 当注入dataSource后，底层会自动创建一个JdbcTemplate --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;c3p0DataSource&quot; /&gt; &lt;/bean&gt; 2. 注解形式: @Repository(&quot;accountDao&quot;) public class AccountDaoImpl extends JdbcDaoSupport implements IAccountDao { // 第一种: 为dao注入dataSource. 较常用 @Autowired @Qualifier(&quot;dataSource&quot;) public void setSuperDataSource(DataSource dataSource) { super.setDataSource(dataSource); } // 第二种: 为dao注入 @Autowired private JdbcTemplate jdbcTemplate; } 本质: 就是能 拿到jdbcTemplate.执行sql语句"},{"title":"","date":"2019-04-23T08:41:10.479Z","path":"2019/04/23/09_Spring中环绕通知/","text":"Spring中的环绕通知:1.概述 问题: 当我们配置了环绕通知之后,切入点方法没有执行,而通知方法执行了 分析: 通过对比动态代理的环绕通知代码,发现动态代理的环绕通知有明确的切入点方法调用.而我们的没有 解决: Spring框架为我们提供了一个接口,proceedingJoinPoint.该接口有一个方法proceed()此方法就相当于明确调用切入点方法. 该接口可以作为环绕通知的方法参数,在程序执行时,Spring框架会为我们提供该接口的实现类供我们使用 Spring中的环绕通知: 它是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式 2. 使用 2.1 基于注解: @Aspect public class AnnotationAudienceAround{ //使用@Pointcut注解声明切入点表达式 @Pointcut(&quot;execution(* com.qin.util.*.*(..))&quot;) public void pt1(){} @Around(&quot;pt1()&quot;) public Object aroundPringLog(ProceedingJoinPoint pjp){ Object rtValue = null; try{ Object[] args = pjp.getArgs();//得到方法执行所需的参数 System.out.println(&quot;Logger类中的aroundPringLog方法开始记录日志了。。。前置&quot;); rtValue = pjp.proceed(args);//明确调用业务层方法（切入点方法） System.out.println(&quot;Logger类中的aroundPringLog方法开始记录日志了。。。后置&quot;); return rtValue; }catch (Throwable t){ System.out.println(&quot;Logger类中的aroundPringLog方法开始记录日志了。。。异常&quot;); throw new RuntimeException(t); }finally { System.out.println(&quot;Logger类中的aroundPringLog方法开始记录日志了。。。最终&quot;); } } } 2.2 基于XML配置文件: 1. 通知类. //去掉了所有的注解 public class XmlAudienceAround{ public Object aroundPringLog(ProceedingJoinPoint pjp){ Object rtValue = null; try{ Object[] args = pjp.getArgs();//得到方法执行所需的参数 System.out.println(&quot;Logger类中的aroundPringLog方法开始记录日志了。。。前置&quot;); rtValue = pjp.proceed(args);//明确调用业务层方法（切入点方法） System.out.println(&quot;Logger类中的aroundPringLog方法开始记录日志了。。。后置&quot;); return rtValue; }catch (Throwable t){ System.out.println(&quot;Logger类中的aroundPringLog方法开始记录日志了。。。异常&quot;); throw new RuntimeException(t); }finally { System.out.println(&quot;Logger类中的aroundPringLog方法开始记录日志了。。。最终&quot;); } } } 2. 在xml文件中配置 &lt;!--声明bean--&gt; &lt;bean name=&quot;xmlAudienceAround&quot; class=&quot;com.qin.util.XmlAudienceAround&quot;/&gt; &lt;!--配置切面及通知--&gt; &lt;aop:config&gt; &lt;aop:aspect ref=&quot;xmlAudienceAround&quot;&gt; &lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(* com.qin.util.*.*(..))&quot;/&gt; &lt;aop:around method=&quot;aroundPringLog&quot; pointcut-ref=&quot;pt1&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;"},{"title":"","date":"2019-04-23T08:41:10.473Z","path":"2019/04/23/08_动态代理以及Spring的AOP/","text":"动态代理特点: 字节码随用随创建,随用随加载 作用: 不修改源码的基础上对方法增强 分类: 1. 基于接口的动态代理 涉及的类: Proxy 提供者: jdk官方 如何创建代理对象: 使用Proxy类中的newProxyInstance方法 创建代理对象的要求: 被代理的类至少实现一个接口,如果没有则不能使用 newProxyInstance方法的参数: ClassLoader:类加载器 它是用于加载代理对象字节码的,和被代理对象使用相同的类加载器,固定写法 Class[]:字节码数组 它是用于让代理对象和被代理对象有相同的方法,固定写法 InvocationHandler:用于提供增强的代码 它是用于让我们写如何代理,我们一般都是写一个该接口的实现类,通常是一个匿名内部类(不是必须的) 此接口的实现类都是谁用谁写 *存在的问题:当我们的类没有实现任何的接口的时候是不可以使用的 代理对象执行方法,其实就是代替被代理对象执行方法 被代理对象实现接口 生成代理对象 代理对象.被代理对象的方法 2. 基于子类的动态代理(cglib) 涉及的类: Enhancer 提供者: 第三方cglib库 如何创建代理对象: 使用Enhancer类中的create方法 创建代理对象的要求: 被代理的类不是最终类,不能被final修饰 create方法的参数: Class:字节码 它是用于指定被代理对象的字节码 Callback:用于提供增强的代码 它是用于让我们写如何代理,我们一般都是写一个该接口的实现类,通常是一个匿名内部类(不是必须的) 此接口的实现类都是谁用谁写 我们一般写的都是该接口的子接口实现类:MethodIntercepor Spring中的AOP概述: AOP：全称是 Aspect Oriented Programming 即：面向切面编程。 简单的说它就是把我们程序重复的代码抽取出来，在需要执行的时候，使用动态代理的技术，在不修改源码的 基础上，对我们的已有方法进行增强 作用以及优势: 作用： 在程序运行期间，不修改源码对已有方法进行增强。 优势： 减少重复代码 提高开发效率 维护方便 实现方式: 使用动态代理技术 AOP相关术语: 连接点: 目标对象的所有方法(所有的切入点都是连接点) 切入点: 被增强的都是切入点 增强/通知: 关于增强的代码块(可以是抽取出来的类) 引介: 是一种特殊的通知在不修改类代码的前提下, Introduction 可以在运行期为类动态地添加一些方法或 Field。 Target: 被代理的对象 织入: 是指把增强应用到目标对象来创建新的代理对象的过程。 spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入。 代理(Proxy): 一个类被AOP织入增强后,产生的结果代理类 切面: 切入点与通知的结合 Spring在AOP开发中代理方式的选择proxy-target-class 默认false: 自动选择 true: 使用cglib代理 1. 基于XML的 &lt;aop:config proxy-target-class=&quot;true&quot;&gt; ..... &lt;/aop:config&gt; 2. 基于注解 &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;&gt;&lt;/aop:aspectj-autoproxy&gt;"},{"title":"","date":"2019-04-23T08:41:10.461Z","path":"2019/04/23/07_spring整合junit/","text":"Spring整合Junit* 问题:在spring中的junit中无法使用容器的对象 * 分析 1. 程序的运行需要main方法 2. junit的运行可以不需要main方法,只是执行了@Test注解的方法 3. junit不会管我们是否采用spring框架 在执行测试方法时，junit根本不知道我们是不是使用了spring框架 所以也就不会为我们读取配置文件/配置类创建spring核心容器 * 结论: 当测试方法执行时，没有Ioc容器，就算写了Autowired注解，也无法实现注入 * 解决办法: 1. 导入spring整合junit的jar(坐标) spring-test 2. 使用junit提供的一个注解把原有的main方法替换了,替换成spring中提供的 @RunWith: @RunWith(SpringJUnit4ClassRunner.class) 3. 告知spring的运行器,spring和ioc创建是基于xml还是基于注解的.并且说明位置 @ContextConfiguration location:指定xml文件的位置,加上classpath关键字,表示在类路径下 @ContextConfiguration(locations = &quot;classpath:ApplicationContext.xml&quot;) classes:指定注解类所在的位置 @ContextConfiguration(classes = SpringConfig.class) * 当我们使用spring5版本的时候,要求junit的jar包必须是4.1.2以及以上 4. 在使用的时候直接在变量上加@Autowired注解就可以 * 例: @RunWith(SpringJUnit4ClassRunner.class) //@ContextConfiguration(locations=&quot;classpath:ApplicationContext.xml&quot;)//基于xml @ContextConfiguration(classes = SpringConfig.class)//基于注解 public class SpringJunit { @Autowired private IAccountService service; @Test public void testFindAll(){ List&lt;Account&gt; all = service.findAll(); for (Account account : all) { System.out.println(account); } } }"},{"title":"","date":"2019-04-23T08:41:10.458Z","path":"2019/04/23/06_DButils的使用/","text":"DButils的基本使用1. 获取QueryRunner对象(相当于JdbcTemplate) 构造(常用): QueryRunner runner = new QueryRunner(); QueryRunner runner = new QueryRunner(param); 参数: 第一个没有参数 第二个的参数是数据库连接池(可以使用c3p0/druid) 2. 执行sql语句 增删改: runner.update(“增删改sql”,参数列表); 查询: runner.query(“查询sql”,返回数据，参数列表); 增: runner.update(&quot;insert into account(name,money)values(?,?)&quot;,account.getName(),account.getMoney()); 删: runner.update(&quot;delete from account where id = ? &quot;,account.getId()) 改: runner.update(&quot;update account set name = ? and money=? where id = ?&quot;,account.getName(),account.getMoney() ,account.getId()) 查: 查一个 runner.query(&quot;select * from account where id = ?&quot;,new BeanHandler&lt;Account&gt;(Account.class),id) 查多个 runner.query(&quot;select * from account&quot;, new BeanListHandler&lt;Account&gt;(Account.class)) * 注: 一条数据使用BeanHandler 多条数据使用BeanListHandler DButils在Spring中IOC的应用*基于xml的配置:(构造的方式传递ds) &lt;bean class=&quot;org.apache.commons.dbutils.QueryRunner&quot; id=&quot;queryRunner&quot;&gt; &lt;constructor-arg name=&quot;ds&quot; ref=&quot;c3p0DataSource&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=&quot;c3p0DataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password&quot;&gt;&lt;/property&gt; &lt;/bean&gt; * 基于注解的配置 @Configuration //作为注解文件被识别 @PropertySource(&quot;classpath:jdbcConfig.properties&quot;)//拆分引入数据库配置文件 @ComponentScan({&quot;com.qin&quot;,&quot;Config&quot;}) //扫描文件 public class SpringConfig { //配置jdbc的连接数据 @Value(&quot;${jdbc.driver}&quot;) private String driver; @Value(&quot;${jdbc.url}&quot;) private String url; @Value(&quot;${jdbc.username}&quot;) private String username; @Value(&quot;${jdbc.password}&quot;) private String password; @Bean public QueryRunner getQueryRunner(DataSource dataSource){ return new QueryRunner(dataSource); } @Bean public DataSource getDataSource(){ try { ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource(); comboPooledDataSource.setDriverClass(driver); comboPooledDataSource.setJdbcUrl(url); comboPooledDataSource.setUser(username); comboPooledDataSource.setPassword(password); return comboPooledDataSource; } catch (PropertyVetoException e) { e.printStackTrace(); return null; } } }"},{"title":"","date":"2019-04-23T08:41:10.446Z","path":"2019/04/23/05_spring中注解形式的AOP/","text":"Spring中基于注解的AOP1. 目标对象 即被代理的对象 如:业务层的AccountServiceImpl 2. 通知对象 即散落在其他类中可以抽取成共性的代码块,可以提取成为一个类(比如日志记录,代码性能监控) 3. 在核心配置中开启对AOP的支持 &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; 4. 使用注解在通知上配置切面 4.0 表示当前类是一个切面类 @Aspect 4.1 配置切点 @Pointcut(&quot;execution(* com.itheima.service.impl.*.update(..))&quot;) private void pt1(){} @Pointcut(&quot;execution(* com.itheima.service.impl.*.save(..))&quot;) private void pt2(){} 4.3 在方法上配置注解 @Before 前置通知 @After 最终通知 @AfterReturning 后置通知 @AfterThrowing 异常通知 @Around 环绕通知"},{"title":"","date":"2019-04-23T08:41:10.415Z","path":"2019/04/23/04_spring中XML形式的AOP/","text":"Spring中基于XML的AOP的配置1. 把通知bean交给Spring来管理 2. 使用aop:config标签表明开始AOP的配置 3. 使用aop:aspect标签表明开始配置切面 id属性:给切面提供一个唯一标识 ref属性:是指定通知类bean的id 4. 在aop:aspect标签的内部使用对用的标签来配置通知的类型 前置通知: aop:before(表示配置前置通知) method属性:用于指定类中哪个方法是前置通知 pointcut属性:用于指定切入点表达式,该表达式的含义指的是对业务层的哪些方法增强 切入点表达式的写法: 关键字: execution(表达式) 表达式: 访问修饰符 返回值 包名.包名...类名.方法名(参数列表) 标准表达式的写法: execution(public void com.qin.service.impl.AccountServiceImpl.xxx(..)) 访问修饰符可以省略 void com.itheima.service.impl.AccountServiceImpl.saveAccount() 返回值可以使用通配符，表示任意返回值 * com.itheima.service.impl.AccountServiceImpl.saveAccount() 包名可以使用通配符，表示任意包。但是有几级包，就需要写几个*. * *.*.*.*.AccountServiceImpl.saveAccount()) 包名可以使用..表示当前包及其子包 * *..AccountServiceImpl.saveAccount() 类名和方法名都可以使用*来实现通配 * *..*.*() 参数列表： 可以直接写数据类型： 基本类型直接写名称 int 引用类型写包名.类名的方式 java.lang.String 可以使用通配符表示任意类型，但是必须有参数 可以使用..表示有无参数均可，有参数可以是任意类型 全通配写法： * *..*.*(..) 实际开发中切入点表达式的通常写法： 切到业务层实现类下的所有方法 * com.itheima.service.impl.*.*(..) 5. 例 &lt;!-- 配置目标类--&gt; &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;&lt;/bean&gt; &lt;!-- 配置通知类 --&gt; &lt;bean id=&quot;logger&quot; class=&quot;com.itheima.utils.Logger&quot;&gt;&lt;/bean&gt; &lt;!--配置AOP--&gt; &lt;aop:config&gt; &lt;!-- 配置切入点表达式 id属性用于指定表达式的唯一标识。expression属性用于指定表达式内容 此标签写在aop:aspect标签内部只能当前切面使用。 它还可以写在aop:aspect外面，此时就变成了所有切面可用 --&gt; &lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(* com.itheima.service.impl.*.*(..))&quot;&gt;&lt;/aop:pointcut&gt; &lt;!--配置切面 --&gt; &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt; &lt;!-- 配置前置通知：在切入点方法执行之前执行--&gt; &lt;aop:before method=&quot;beforePrintLog&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:before&gt; &lt;!-- 配置后置通知：在切入点方法正常执行之后值。它和异常通知永远只能执行一个--&gt; &lt;aop:after-returning method=&quot;afterReturningPrintLog&quot; pointcut-ref=&quot;pt1&quot; returning=&quot;val&quot;&gt;&lt;/aop:after-returning&gt; &lt;!-- 配置异常通知：在切入点方法执行产生异常之后执行。它和后置通知永远只能执行一个--&gt; &lt;aop:after-throwing method=&quot;afterThrowingPrintLog&quot; pointcut-ref=&quot;pt1&quot; throwing=&quot;ex&quot;&gt;&lt;/aop:after-throwing&gt; &lt;!-- 配置最终通知：无论切入点方法是否正常执行它都会在其后面执行--&gt; &lt;aop:after method=&quot;afterPrintLog&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after&gt; &lt;!-- 配置环绕通知 --&gt; &lt;aop:around method=&quot;aroundPringLog&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:around&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;"},{"title":"","date":"2019-04-23T08:41:10.388Z","path":"2019/04/23/03_spring抽取配置文件/","text":"Spring抽取配置数据库文件1.抽取文件: jdbcConfig.properties jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/spring jdbc.username=root jdbc.password=root 2. 在Spring的配置文件中配置: &lt;context:property-placeholder location=&quot;jdbcConfig.properties&quot;&gt;&lt;/context:property-placeholder&gt; 使用注解的配置为: @PropertySource(&quot;classpath:jdbcConfig.properties&quot;) 3. 在原来的配置文件中使用Spring的el表达式 ${}来表示 &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password&quot;&gt;&lt;/property&gt;"},{"title":"","date":"2019-04-23T08:41:10.358Z","path":"2019/04/23/02_spring中注解形式的IOC/","text":"Spring的注解开发* IOC在XML的配置:&lt;bean id=&quot;accountService&quot; class=&quot;com.qin.service.impl.AccountService&quot; scope=&quot;&quot; init-method=&quot;&quot; destory-method=&quot;&quot;&gt; &lt;property name=&quot;&quot; value=&quot;&quot; |ref=&quot;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; * 注解分类: 1. 用于创建对象的 它们的作用就和xml配置中编写一个&lt;bean&gt;标签实现的功能是一样的 @Component: 作用: 用于把当前类对象存入Spring容器中 属性: value:用于指定bean中的id.当我们不写时,他的默认值是当前类名的,且首字母小写 @Controller:一般用在表现层 @Service:一般用在业务层 @Repository:一般用在持久层 以上三个注解的作用和属性与Component是一模一样的 他们三个是spring为我们提供明确的三层使用的注解,使我们的三层对象更加清晰 在xml文件的配置: &lt;context:component-scan base-package=&quot;com.qin&quot;&gt;&lt;/context:component-scan&gt; 作用:告知spring在创建容器时要扫描的包,配置所需要的标签不是beans约束中,而是在context 的名称空间和约束中 约束配置: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; 2. 用于注入数据的 它们的作用就和在xml配置文件中的bean标签中写一个&lt;property&gt;标签的作用是一样的 @Autowired 作用:(自动按照类型注入) 如果ioc容器中有唯一的一个bean对象类型和要注入的变量类型匹配,就可以注入成功 如果ioc容器中没有任何bean类型和要注入的变量类型一致,将会注入失败 如果ioc容器中有多个bean类型和要注入的变量类型一致,会先根据类型寻找,再根据变量名找 出现位置: 变量上,方法上(在set方法上也可以使用); 细节: 在使用注解注入时,set方法就不是必须的 @Qualifier * 配合@Autowired使用 * 也可以存在于参数上,配合指定构造中要传递的bean对象 作用: 在按照类中注入的基础之上再按照名称注入.他在给类成员注入时不能单独使用,但是在给方法参数注入时可以 属性: value:用于指定注入bean的id @Resource * jdk1.9不能使用 作用: 直接按照bean的id注入,它可以单独使用 属性: name:用于指定bean 的id * 以上三个注入都只能注入其他bean类型,而基本类型和string类型无法使用上述注解实现,集合类型也可以用Autowired实现 @Value 作用: 用于注入基本类型和string类型的数据 属性: value:用于指定数据的值.他可以使用spring和spEL(也就是spring的el表达式) spEL的写法:#{表达式} #{}:去容器中找id为花括号内容对应的值 ${}:去配置文件中读取花括号对应的值 3. 用于改变作用范围的 它们的作用就和在xml配置文件中的bean标签中使用scope属性实现的功能是一样的 @Scope 作用: 用于指定bean的作用范围 属性: value:指定范围的取值.常用取值:singleton prototype 4. 和生命周期相关 它们的作用就和在xml配置文件中的bean标签中使用init-method和destory-method的作用是一样的 @PreDestroy 作用: 用于指定销毁方法 @PostConstruct 作用: 用于指定初始化方法 * spring的新注解(可以使用纯注解的形式开发) * 创建一个类.替换核心配置文件 @Configuration 作用: 指定当前类是一个配置类 细节: 当配置类作为AnnotationConfigApplicationContext对象创建的参数时,可以不写此注解 但不是任何时候都可以不写(把注解文件分开写,另一个没有读的配置文件必须写) @ConponentScan 作用: 用于通过注解指定spring在创建容器时要扫面的包 属性: value:它和basePackage的作用是一样的,都是用于指定创建容器时要扫面的包 我们使用次注解就等同于在xml中配置了: &lt;context:component-scan base-package=&quot;com.qin&quot;&gt;&lt;/context:component-scan&gt; @Bean 作用: 用于把当前方法的的返回值作为bean对象存入spring的ioc容器中 属性: name:用于指定bean的id,当不写时,默认值是当前方法的名称 细节: 当我们使用注解来配置方法时,如果方法有参数,spring框架会去容器中查找有没有可用的bean对象,查找的方式和 @Autowired注解的作用一样的 @Import 作用: 用于导入其他的配置类 属性: value:用于指定其他配置类的字节码文件 当我们使用import的注解之后,有import注解的类就是父配置类,而导入的都是子配置类 @PropertySource 作用: 用于指定properties文件的位置 属性: value:指定文件的名称以及文件的路径 关键字:classpath,表示类路径下 例子: @PropertySource(&quot;classpath:JdbcConfig.properties&quot;) *没有xml文件时测试就要修改ApplicationContext的创建方式 ApplicationContext ac = new AnnotationConfigApplicationContext(&quot;被@Configuration注解过的类&quot;.class)"},{"title":"","date":"2019-04-23T08:41:10.344Z","path":"2019/04/23/01_spring中XML形式的IOC/","text":"Spring引入* spring 是什么? Spring是分层的 Java SE/EE应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control： 反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核，提供了展现层 Spring MVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多 著名的第三方框架和类库，逐渐成为使用最多的Java EE 企业应用开源框架。 * 程序的耦合 耦合:程序之间的依赖关系 包括了类与类之间的依赖,方法之间的依赖 解耦:降低程序之间的依赖关系,提升程序的灵活性与可扩展性 实际开发中:应该做到编译期不依赖,运行时才会依赖 解耦的思路: 第一步:使用反射来创建对象,从而避免使用new关键字 第二步:通过读取配置文件来获取要创建的对象全限定类名 * 三层架构代码中存在的问题 业务层调用持久层的时候的new dao的接口 在表现层调用业务层的时候new service的接口 解决办法: 使用工厂模式解耦(一个创建bean对象的工厂) Bean 1. Bean:在计算机英语中,有可重用组件的含义 2. JavaBean:用java语言编写的可重用组件 JavaBean &gt; 实体类 3. POJO（Plain Ordinary Java Object）即普通Java类 4. 可以认为POJO就一个不带方法而单纯承载数据实体Bean；EJB是一个包含了POJO的超集、 包含POJO之外的，具有方法、实现、功能这一群组件。 方法: 1. 一个配置文件配置service与dao的内容(xml/properties) 2. 通过读取配置文件来获取要创建的对象全限定类名,反射加载 3.优化:使用单例 Spring的IOC(Inversion Of Control)* IOC:控制反转 简单理解:让spring来控制对象 一般的pojo或者domain实体类是不会让spring去管理的 通常来说,我们自己写的类,使用注解,别人写的类(引入的类)一般使用xml * 入门案例: 1. 导入依赖 2. 创建配置文件,导入约束,并写入相关的bean标签(配置id与class) 3. 从容器中获取容器对象 3.1 先获取容器 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;配置文件&quot;) 3.2 从容器中根据id或者name获取bean对象 User user = ac.getBean(&quot;user&quot;, User.class); System.out.println(user);//User{userName=&apos;null&apos;, age=null, birthday=null} * ApplicationContext的三个常用的实现类 ClassPathXmlApplicationContext:它可以加载类路径下的配置文的件,要求配置文件必须在类路径下,不在就加载不了 (xml常用) FileSystemXmlApplicationContext:它可以加载磁盘任意路径下的配置文件 (必须有访问权限) AnnotationConfigApplicationContext:它是用于读取注解的配置 (注解时使用) * 核心容器的两个接口引发出的问题 ApplicationContext:(单例对象试用),多使用此接口 它在构建核心容器的时候,创建对象采取的是立即加载的方式,也就是说,只要一读取完配置文件就马上 就创建配置文件中的配置的对象 BeanFactory:(多例对象适用) 它在构建核心容器的时候,采取的策略是延迟加载的方式,也就是说,什么时候根据id获取对象了,什么时候才会 真正的创建对象 * Spring对bean的管理细节 1. 创建bean的三种方式: 1.1 第一种方式:使用默认构造函数创建 在spring的配置文件中使用bean标签,配置id与class属性之后,且没有其他属性和标签时 采用的就是默认构造函数创建bean对象,测试如果类中没有默认构造函数,则对象无法创建 &lt;bean id=&quot;service&quot; class=&quot;com.qin.service.impl.IUserServiceImpl&quot;&gt;&lt;/bean&gt; 1.2 第二种方式:使用普通工厂中的方法来创建对象(使用某个类中的方法创建对象,并存入spring容器) &lt;bean id=&quot;instanceFactory&quot; class=&quot;com.qin.factory.instanceFactory&quot;&gt;&lt;/bean&gt;(要先有对象才能调用方法) &lt;bean id=&quot;serviceFactory&quot; class=&quot;com.qin.factory.instanceFactory&quot; factory-method=&quot;getAccount&quot;&gt; &lt;/bean&gt; 1.3 第三种方式:使用工厂中的静态方法创建对象(使用某个类中的静态方法创建对象,并存入spring容器) &lt;bean id=&quot;serviceFactory&quot; class=&quot;com.qin.factory.StaticFactory&quot; factory-method=&quot;getAccount&quot;&gt; &lt;/bean&gt; 静态方法是不需要对象的,是可以通过全类名调用的,所以不需要对象 2. bean的作用范围 bean标签的scope属性 作用:用于指定bean 的作用范围 取值: singleton:单例的(默认值) prototype:多例的 request:作用于wen应用的请求范围 session:作用于wen应用的会话范围 global-session:作用于集群环境的会话范围(全局会话范围),当不是集群的时候,相当于session 3. bean对象的生命周期 单例对象: 出生:当容器创建时候对象出生 存在:只要容器在,对象就一直活着 死亡:容器销毁,对象消亡 总结:单例对象的生命周期和容器相同 多例对象: 出生:当使用对象时,spring框架为我们创建 存在:对象还在使用的过程中就一直存活 死亡:当对象长时间不用,且没有别的对象引用时,由java的垃圾回收器回收 Spring依赖注入:DI(依赖关系的维护)* 能注入的数据:三类 1. 基本类型和string : 2. 其他bean类型(在配置文件中或者注解配置过的bean) 3. 复杂类型/集合类型 * 注入的方式:有三种 1. 使用构造函数提供(不常用) 使用的标签:constructor-arg 标签出现的位置:bean标签的内部 标签的属性: type:用于指定要注入的数据的数据类型,该数据类型也是构造函数中某个或某些参数的类型 index:用于指定要注入的数据给构造函数中指定索引位置的参数赋值,索引的位置是从0开始的 name:用于指定给构造函数中指定名称的参数赋值(常用) ---------------以上三个用于指定给构造函数中的哪个参数赋值-------------------- value:用于提供基本类型和string类型的数据 ref:用于指定其他的bean类型数据.他指的就是在spring的核心容器中出现过的bean对象 优势: 在获取bean对象时,注入数据是必须的操作,否则对象无法创建成功. 弊端: 改变了bean对象的实例化方式,使我们在创建对象时,如果不使用这些数据也必须提供. 2. 使用set方法提供(常用) * 首先必须有set方法 涉及的标签:property 出现的位置:bean标签的内部 标签的属性: name:用于指定注入时调用的set方法名称 value:用于提供基本类型和string类型的数据 ref:用于指定其他的bean类型数据.他指的就是在spring的核心容器中出现过的bean对象 优势:创建对象时没有明确的限制,可以直接使用默认构造函数 弊端:如果某个成员必须有值,则获取对象是有可能set方法没有执行 3. 使用注解提供 * 示例: 1. 构造函数注入 &lt;bean id=&quot;userDao&quot; class=&quot;com.qin.dao.impl.IUserDaoImpl&quot;&gt; &lt;constructor-arg name=&quot;userName&quot; value=&quot;sakura&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;birthday&quot; ref=&quot;date&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=&quot;date&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt; 2. 使用set方法注入 &lt;bean id=&quot;userDao1&quot; class=&quot;com.qin.dao.impl.IUserDaoImpl1&quot;&gt; &lt;property name=&quot;age&quot; value=&quot;19&quot;&gt;&lt;/property&gt; &lt;property name=&quot;userName&quot; value=&quot;tom&quot;&gt;&lt;/property&gt; &lt;property name=&quot;birthday&quot; ref=&quot;date&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;date&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt; 3. 对集合属性进行set方式注入 &lt;bean id=&quot;userDao2&quot; class=&quot;com.qin.dao.impl.IUserDaoImpl2&quot;&gt; &lt;property name=&quot;myStrs&quot;&gt; &lt;array&gt; &lt;value&gt;string&lt;/value&gt; &lt;value&gt;string&lt;/value&gt; &lt;value&gt;string&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=&quot;myList&quot;&gt; &lt;list&gt; &lt;value&gt;list&lt;/value&gt; &lt;value&gt;list&lt;/value&gt; &lt;value&gt;list&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;mySet&quot;&gt; &lt;set&gt; &lt;value&gt;set&lt;/value&gt; &lt;value&gt;set&lt;/value&gt; &lt;value&gt;set&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=&quot;myMap&quot;&gt; &lt;map&gt; &lt;entry key=&quot;map1&quot;&gt; &lt;value&gt;map1&lt;/value&gt; &lt;/entry&gt; &lt;entry key=&quot;map2&quot; value=&quot;map2&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;map3&quot; value=&quot;map3&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;myProps&quot;&gt; &lt;props&gt; &lt;prop key=&quot;prop&quot;&gt;123&lt;/prop&gt; &lt;prop key=&quot;prop&quot;&gt;123&lt;/prop&gt; &lt;prop key=&quot;prop&quot;&gt;123&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;"},{"title":"Hello World","date":"2019-04-23T08:36:59.110Z","path":"2019/04/23/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]